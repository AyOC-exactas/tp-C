\documentclass[]{scrartcl}
\usepackage[a4paper,left=2cm,right=3cm,top=2cm,bottom=2cm]{geometry}
\usepackage{svg}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{minted}
\usepackage{tcolorbox}
\usepackage[spanish]{babel}
\usepackage{mdframed}
\usepackage{epigraph}
\usepackage{wrapfig}


\tcbuselibrary{minted}
\tcbuselibrary{breakable}

\definecolor{bashcodebg}{rgb}{0.85,0.85,0.85}

\newtcolorbox{notebox}{colback=SpringGreen!15!white,
colframe=SpringGreen!50!black}

\newtcolorbox{importantbox}{colback=RubineRed!25!white,colframe=RubineRed!75!black}

\newtcolorbox[auto counter]{exbox}[1][]{%
colback=red!5!white,colframe=red!75!black,
fonttitle=\bfseries,
title=Ejercicio \thetcbcounter: , #1}

\newtcblisting[auto counter]{cbox}[2][]{%
listing engine=minted,
minted language=c,
minted style=colorful,
minted options={mathescape,autogobble, framesep},
colback=TealBlue!5!white,colframe=TealBlue!75!black,
fonttitle=\bfseries,
listing only,
title=Snippet \thetcbcounter: #2, 
nameref=Snippet \thetcbcounter: #2,
#1}

\newminted[ccode]{c}{
  style=colorful,
  linenos=false,
  autogobble,
  fontsize=\footnotesize,
  bgcolor=gray!5,
  framesep=2mm,
  baselinestretch=1.2 % Adjust line height if needed
}

\newtcblisting[auto counter]{bashbox}[1][]{%
listing engine=minted,
minted language=bash,
minted style=colorful,
minted options={mathescape,autogobble, framesep},
colback=bashcodebg,
colframe=black!70,
fonttitle=\bfseries,
listing only,
#1}

\newtcbinputlisting[]{\bashinput}[2][]{%
listing file={#2},
listing engine=minted,
minted language=bash,
minted style=colorful,
minted options={autogobble, framesep},
colback=bashcodebg,
colframe=black!70,
fonttitle=\bfseries,
listing only,
#1}

\usepackage{colortbl} % para /color
\usepackage{hyperref} % Necesario para \url y \href
\usepackage{caption} % Para usar captionof
\captionsetup{labelformat=empty, hypcap=false}

\hypersetup{
    colorlinks=true,
    linkcolor=CadetBlue,
    filecolor=CadetBlue,      
    urlcolor=CadetBlue,
    }

\newcommand{\hl}[1]{\textcolor{magenta}{\textbf{\texttt{#1}}}}

%opening
\title{Guía de C - avanzada}
\subtitle{Arquitectura y Organización del Computador}
\date{}
\begin{document}


\maketitle

\section*{Punteros}
\subsection*{¿Qué es un puntero?}
\label{sec:introduccion}

\begin{importantbox}
  \centering
  Un puntero es una \textbf{variable que almacena una dirección de memoria}.
\end{importantbox}

En la guía anterior mencionamos al pasar que uno de los tipos nativos de C es el \textbf{puntero}, tipado \texttt{int*, char*, void*, etc}.
Comencemos mirando el siguiente código:

\begin{cbox}[unbreakable,label=sni:xp,nameref={Snippet \ref{sni:xp}}]{}
  #include <stdio.h>

  int main(){
      int x = 42;
      int *p = &x;
  
      printf("Direccion de x:  %p Valor: %d\n", (void*) &x, x);
      printf("Direccion de p: %p Valor: %p\n", (void*) &p, (void*) p);
      printf("Valor de lo que apunta p: %d\n", *p);
  }
\end{cbox}

\begin{exbox}[label=ejercicio1]
  Sin correr el código, responder:
  \begin{itemize}
    \item ¿Cuál es la diferencia entre x y p? ¿Y entre \texttt{x} y \texttt{\&x}? ¿Y entre \texttt{p} y \texttt{*p}?
    \item ¿Qué valores creen que se van a imprimir por terminal?
  \end{itemize}
\end{exbox}

\begin{exbox}[label=ejercicio2]
  Compilar y ejecutar el código. 
  ¿Qué valores se imprimieron?
  ¿Qué creen que significan?
\end{exbox}

Para responder estas preguntas, es \textbf{clave} que entendamos como se organiza la memoria en C.

Al final del día, la memoria no es más que una tira de \textbf{bits} (1/0).
Pero usualmente queremos trabajar con variables con más valores que solo 0 y 1\footnote{Tener memorias del tamaño que utilizamos hoy direccionables con granularidad de bit sería caro y dificultoso de implementar a nivel hardware. Este post de quora da una intuición al respecto \url{https://www.quora.com/Why-do-memory-addresses-use-the-unit-of-byte-instead-of-bit}.}, por lo que hoy en día usamos a la memoria como si fuera una tira de \textbf{bytes}, que son grupos de \textbf{8 bits}.

\begin{wrapfigure}{r}{0.2\paperwidth}
  \includegraphics[width=0.2\paperwidth]{./img/lionelhutz-contract.png}
  \label{fig:simpsons-puntero}
\end{wrapfigure} 

Entonces, desde ahora, pensemos a la memoria como una \textbf{tira de bytes contiguos}.
Vamos a poder acceder a cada uno de estos bytes individualmente, porque cada uno tiene una \textbf{dirección única} que lo identifica.

Llamamos \textbf{puntero} a una variable que guarda la dirección de un valor en memoria. Por ejemplo, si la memoria de la dirección 0xF0 (hexadecimal) a 0xF8 tiene esta pinta:
%
\begin{center}
  \noindent \makebox[\textwidth]{\includegraphics[width=0.5\paperwidth]{./img/memoria_bytes.png}}
  \label{fig:tira-memoria}
\end{center}
%
Podríamos declarar las siguientes variables:
\begin{cbox}[unbreakable]{}
  #include <stdio.h>
  #include <stdint.h>

  int main(){
    uint8_t *x = (uint8_t*) 0xF0;
    int8_t *y = (int8_t*) 0xF6;

    printf("Dir de x: %p Valor: %d\n", (void*) x, *x);
    printf("Dir de y: %p Valor: %d\n", (void*) y, *y);

    //Devolverá:
    //  Dir de x: 0xF0 Valor: 255
    //  Dir de y: 0xF6 Valor: -128
  }
\end{cbox}

\begin{exbox}[label=ejercicio3]
  ¿Por qué x e y tienen distintos tipos? ¿Qué representan?
\end{exbox}

Si intentan ejecutar ese código, probablemente el programa falle con un error de tipo \texttt{Segmentation fault (core dumped)}.
En nuestra computadora, la memoria esta siendo usada por varios componentes y es estadísticamente imposible que las direcciones 0xF0 a 0xF8 tengan los valores que usamos en este ejemplo.
De hecho, las direcciones 0xF0 a 0xF8 de memoria probablemente no estén a nuestro alcance porque seguramente las esté usando otro proceso (por ende ocurre un \texttt{Segmentation Fault}).

Si queremos una tira contigua de bytes como la mostrada en la imagen, necesitamos declararla.
Para eso, podemos usar arrays! Como vimos en la guía anterior.

\begin{exbox}[label=ejercicio4]
  Completar los ?? en el siguiente código:

  \begin{cbox}[unbreakable]{}
    #include <stdio.h>
    #include <stdint.h>

    int main(){
        int8_t memoria[??] = ??;
        uint8_t *x = (uint8_t*) ??;
        int8_t *y = ??;

        printf("Dir de x: %p Valor: %d\n", (void*) x, *x);
        printf("Dir de y: %p Valor: %d\n", (void*) y, *y);
    }
  \end{cbox}

  \textbf{Pista:} ¿Para qué sirve el operador \texttt{\&}? Revisar los ejemplos de código anteriores o ver la sección \nameref{sec:operadores}.
\end{exbox}

\subsection*{Operando con punteros} 
\label{sec:operadores}

Habrán visto en los ejemplos hasta ahora que al trabajar con punteros contamos con dos operadores principales: \texttt{*} y \texttt{\&}.
Definamos propiamente:

\begin{itemize}
  \item \texttt{*}: se usa en dos situaciones
  \begin{itemize}
    \item Al \textbf{declarar} un puntero: indica que la variable siendo declarada es un puntero al tipo indicado.
    Por ejemplo, \texttt{int *num;} significa que \texttt{num} es un puntero a un número entero.
    \item Cuando acompaña a una variable ya declarada: nos permite \textbf{desreferenciar} la variable que acompaña (que debería ser un puntero), permitiendonos acceder al valor que se encuentra en la dirección guardada en la variable.
    
    Por ejemplo, en el \nameref{sni:xp}, pueden ver que en el último printf, donde imprimimos el valor de lo que apunta p, para acceder a ese valor usamos \texttt{*p}. 
    Efectivamente, ese printf resulta en que se imprima 42 a consola.
  \end{itemize}
  \item \texttt{\&}: se usa para obtener la dirección de una variable.
  En el \nameref{sni:xp}, usamos \texttt{\&x} para declarar p ya que queríamos que el puntero p guardara la dirección de la variable x (es decir, la dirección donde está guardado el valor 42). 
\end{itemize}

\subsection*{Punteros a punteros}

Hasta ahora solo usamos punteros a valores enteros, pero dado que un puntero no es más que la dirección de memoria de algún valor de algún tipo, podemos tener \textbf{punteros a cualquier cosa}.
Incluso podemos tener punteros a punteros!

Algunos ejemplos:
\begin{itemize}
  \item \texttt{char*}: puntero a una tira de \texttt{char}s. Si su último carácter es un \hl{\textquotesingle\textbackslash0\textquotesingle}, es equivalente a un string.
  \item \texttt{int**}: puntero (\texttt{int*\textcolor{red}{*}}) a un puntero a un entero (\texttt{\textcolor{red}{int*}*})
  \item \textbf{void*}: puntero a un tipo \textbf{desconocido}.
        No se puede desreferenciar sin antes especificar su tipo mediante un \textbf{casteo}.
\end{itemize}
%
\begin{center}
  \noindent \makebox[\textwidth]{\includegraphics[width=0.7\paperwidth]{./img/puntero y doble puntero.png}}
  \label{fig:doble-puntero}
\end{center}

\subsection*{Castear}

\subsection*{Tipos de memoria}

Tenemos varios tipos de memoria, y en cuál se encuentra nuestra variable dependerá de dónde y cómo declaramos nuestras variables.

\begin{center}
  \begin{table}[!h]
    \centering
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|c|c|c|}
    \hline
    \rowcolor[HTML]{333333} 
    {\color[HTML]{FFFFFF} \textbf{Tipos de memoria}} & {\color[HTML]{FFFFFF} \textbf{Scope}} & {\color[HTML]{FFFFFF} \textbf{Lifetime}}                                      \\ \hline
    Global                                           & El archivo completo                   & \begin{tabular}[c]{@{}c@{}}el tiempo de vida \\ de la aplicación\end{tabular} \\ \hline
    Estática &
      \begin{tabular}[c]{@{}c@{}}La función (o bloque) \\ donde está declarada\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}el tiempo de vida \\ de la aplicación\end{tabular} \\ \hline
    Automática (local) &
      \begin{tabular}[c]{@{}c@{}}La función (o bloque) \\ donde está declarada\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Mientras la función (o bloque)\\ esté en ejecución\end{tabular} \\ \hline
    Dinámica &
      \begin{tabular}[c]{@{}c@{}}Determinado por los punteros que\\  referencian esta memoria\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Hasta que la memoria\\  sea liberada\end{tabular} \\ \hline
    \end{tabular}%
    }
    \end{table}
  
\end{center}
\end{document}
